// LinkSample.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

#include <Windows.h>	// needed by CHILKAT e.g. for SystemTime
// added for CHILKAT
#include "..\include\ckimap.h" 
//#include "..\include\tchar.h"
//
// need this for various things
extern "C" {
#include "../include/allC.h"
#include "../include/allUnicodeC.h"
}
#include "../include/allUnicode.h"

// for the AES Encryption & Hashing
#include "../include/CkCrypt2.h"

// for RSA
#include "../include/CkRsa.h"

//for DH algorithm
#include "../include/CkDh.h"

// get strings, because the const char* causes problems....
#include <iostream>
#include <string>
#include <CkDh.h>
#include <CkCrypt2.h>
using namespace std;

void CreateSessionKey(void); //128 bits 
//DH algorithm for mutually generating a password
void CreateSessionKey(void) 
{
	//  Create two separate instances of the DH object.
	CkDh dhBob;
	CkDh dhAlice;

	bool success;

	//  Unlock the component once at program startup...
	success = dhBob.UnlockComponent("T12302015Diffie_eegQ20BTIR5q");
	if (success != true) {
		std::cout << dhBob.lastErrorText() << "\r\n\n";
		return;
	}


//  The DH algorithm begins with a large prime, P, and a generator, G.
//  These don't have to be secret, and they may be transmitted over an insecure channel.
//  The generator is a small integer and typically has the value 2 or 5.

//  The Chilkat DH component provides the ability to use known
//  "safe" primes, as well as a method to generate new safe primes.

//  This example will use a known safe prime.  Generating
//  new safe primes is a time-consuming CPU intensive task
//  and is normally done offline.

//  Bob will choose to use the 2nd of our 8 pre-chosen safe primes.
//  It is the Prime for the 2nd Oakley Group (RFC 2409) --
//  1024-bit MODP Group.  Generator is 2.
//  The prime is: 2^1024 - 2^960 - 1 + 2^64 * { [2^894 pi] + 129093 }
dhBob.UseKnownPrime(2);

//  The computed shared secret will be equal to the size of the prime (in bits).
//  In this case the prime is 1024 bits, so the shared secret will be 128 bytes (128 * 8 = 1024).
//  However, the result is returned as an SSH1-encoded bignum in hex string format.
//  The SSH1-encoding prepends a 2-byte count, so the result is going  to be 2 bytes
//  longer: 130 bytes.  This results in a hex string that is 260 characters long (two chars
//  per byte for the hex encoding).

const char *p = 0;
int g;
//  Bob will now send P and G to Alice.
p = dhBob.p();
g = dhBob.get_G();

//  Alice calls SetPG to set P and G.  SetPG checks
//  the values to make sure it's a safe prime and will
//  return false if not.
success = dhAlice.SetPG(p, g);
if (success != true) {
	std::cout << "P is not a safe prime" << "\r\n";
	return;
}
//  Each side begins by generating an "E"
//  value.  The CreateE method has one argument: numBits.
//  It should be set to twice the size of the number of bits
//  in the session key.

//  Let's say we want to generate a 128-bit session key
//  for AES encryption.  The shared secret generated by the Diffie-Hellman
//  algorithm will be longer, so we'll hash the result to arrive at the
//  desired session key length.  However, the length of the session
//  key we'll utlimately produce determines the value that should be
//  passed to the CreateE method.

//  In this case, we'll be creating a 128-bit session key, so pass 256 to CreateE.
//  This setting is for security purposes only -- the value
//  passed to CreateE does not change the length of the shared secret
//  that is produced by Diffie-Hellman.
//  Also, there is no need to pass in a value larger
//  than 2 times the expected session key length.  It suffices to
//  pass exactly 2 times the session key length.

//  Bob generates a random E (which has the mathematical
//  properties required for DH).
const char *eBob = 0;
eBob = dhBob.createE(256);

//  Alice does the same:
const char *eAlice = 0;
eAlice = dhAlice.createE(256);

//  The "E" values are sent over the insecure channel.
//  Bob sends his "E" to Alice, and Alice sends her "E" to Bob.

//  Each side computes the shared secret by calling FindK.
//  "K" is the shared-secret.

const char *kBob = 0;
const char *kAlice = 0;

//  Bob computes the shared secret from Alice's "E":
kBob = dhBob.findK(eAlice);

//  Alice computes the shared secret from Bob's "E":
kAlice = dhAlice.findK(eBob);

//  Amazingly, kBob and kAlice are identical and the expected
//  length (260 characters).  The strings contain the hex encoded bytes of
//  our shared secret:
std::cout << "Bob's shared secret:" << "\r\n\n";
std::cout << kBob << "\r\n\n";
std::cout << "Alice's shared secret (should be equal to Bob's)" << "\r\n\n";
std::cout << kAlice << "\r\n\n";

//  To arrive at a 128-bit session key for AES encryption, Bob and Alice should
//  both transform the raw shared secret using a hash algorithm that produces
//  the size of session key desired.   MD5 produces a 16-byte (128-bit) result, so
//  this is a good choice for 128-bit AES.

//  Here's how you would use Chilkat Crypt (a separate Chilkat component) to
//  produce the session key:
CkCrypt2 crypt;

//  Any string argument automatically begins the 30-day trial.
bool success1;
success1 = crypt.UnlockComponent("T12302015Crypt_sHyDCAFglR1v");
if (success1 != true) {
	printf("Crypt component unlock failed\n");
	return;
}

crypt.put_HashAlgorithm("md5");
crypt.put_EncodingMode("hex");

const char *sessionKey = 0;
sessionKey = crypt.hashStringENC(kBob);

std::cout << "128-bit Session Key:" << "\r\n";
std::cout << sessionKey << "\r\n\n";

}

// RSA example function. You may need to alter this to allow parameter passing etc..
void RSA(void);

//Function to pause your program - for debugging purposes. Could also use this command [ system("pause"); ]
void key_press(void);

void key_press(void)
{
	cout << "\nPress Any Key to Continue!\n\n";
	do {} while (!getchar());
}

void RSA(void)
{
	CkRsa rsa;

	bool success;
	success = rsa.UnlockComponent("T12302015RSA_nn56BzHGIRMg");
	if (success != true) {
		printf("RSA component unlock failed\n");
		return;
	}

	//  This example also generates the public and private
	//  keys to be used in the RSA encryption.
	//  Normally, you would generate a key pair once,
	//  and distribute the public key to your partner.
	//  Anything encrypted with the public key can be
	//  decrypted with the private key.  The reverse is
	//  also true: anything encrypted using the private
	//  key can be decrypted using the public key.

	//  Generate a 1024-bit key.  Chilkat RSA supports
	//  key sizes ranging from 512 bits to 4096 bits.
	//cut out the code and only use it wheen key generation is needed
	success = rsa.GenerateKey(1024);  
	if (success != true) {
		printf("%s\n", rsa.lastErrorText());
		return;
	}

	//  Keys are exported in XML format:
	const char * publicKey;
	publicKey = rsa.exportPublicKey();
	std::cout << "RSA Public Key:" << "\r\n";
	std::cout << publicKey << "\r\n\n";
	const char * privateKey;
	privateKey = rsa.exportPrivateKey();
	std::cout << "RSA Private Key:" << "\r\n";
	std::cout << privateKey << "\r\n\n";

	// Store the 2 keys at this point for later use.

	const char * plainText;
	plainText = "Encrypting and decrypting should be easy!";

	//  Start with a new RSA object to demonstrate that all we
	//  need are the keys previously exported:
	CkRsa rsaEncryptor;

	//  Encrypted output is always binary.  In this case, we want
	//  to encode the encrypted bytes in a printable string.
	//  Our choices are "hex", "base64", "url", "quoted-printable".
	rsaEncryptor.put_EncodingMode("hex");

	//  We'll encrypt with the public key and decrypt with the private
	//  key.  It's also possible to do the reverse.
	rsaEncryptor.ImportPublicKey(publicKey);

	bool usePrivateKey;
	usePrivateKey = false;
	const char * encryptedStr;
	encryptedStr = rsaEncryptor.encryptStringENC(plainText, usePrivateKey);
	printf("%s\n", encryptedStr);

	//  Now decrypt:
	CkRsa rsaDecryptor;

	rsaDecryptor.put_EncodingMode("hex");
	rsaDecryptor.ImportPrivateKey(privateKey);

	usePrivateKey = true;
	const char * decryptedStr;
	decryptedStr = rsaDecryptor.decryptStringENC(encryptedStr, usePrivateKey);

	printf("%s\n", decryptedStr);
}

void digitalSig(void)
{
	CkRsa rsa;

	bool success;
	success = rsa.UnlockComponent("T12302015RSA_nn56BzHGIRMg");
	if (success != true) {
		printf("RSA component unlock failed\n");
		return;
	}

	// this code operates the same as the above RSA but swaps the use of the private key and public key
	// a little more work will have to be done to split this function into signing the message and
	// validate the message afterwards
	success = rsa.GenerateKey(1024);  
	if (success != true) {
		printf("%s\n", rsa.lastErrorText());
		return;
	}

	//  Also this could work with the keys that are created at startup so most of the code below is 
	// pretty redundant!
	const char * publicKey;
	publicKey = rsa.exportPublicKey();
	std::cout << "RSA Public Key:" << "\r\n";
	std::cout << publicKey << "\r\n\n";
	const char * privateKey;
	privateKey = rsa.exportPrivateKey();
	std::cout << "RSA Private Key:" << "\r\n";
	std::cout << privateKey << "\r\n\n";

	// Store the 2 keys at this point for later use.

	const char * plainText;
	plainText = "Check out my digital signature!";

	//  everything below this point can be the same since we still need the encryptor/decryptor object
	// but still need to be split up!
	CkRsa rsaEncryptor;

	//  Encrypted output is always binary.  In this case, we want
	//  to encode the encrypted bytes in a printable string.
	//  Our choices are "hex", "base64", "url", "quoted-printable".
	rsaEncryptor.put_EncodingMode("hex");

	//  We'll encrypt with the public key and decrypt with the private
	//  key.  It's also possible to do the reverse.
	rsaEncryptor.ImportPublicKey(publicKey);

	// this boolean is a GODSEND
	bool usePrivateKey;
	usePrivateKey = true;
	const char * encryptedStr;
	encryptedStr = rsaEncryptor.encryptStringENC(plainText, usePrivateKey);
	printf("%s\n", encryptedStr);

	//  Now decrypt:
	CkRsa rsaDecryptor;

	rsaDecryptor.put_EncodingMode("hex");
	rsaDecryptor.ImportPrivateKey(privateKey);

	usePrivateKey = false;
	const char * decryptedStr;
	decryptedStr = rsaDecryptor.decryptStringENC(encryptedStr, usePrivateKey);

	printf("%s\n", decryptedStr);
}

void AES(void)
{
	CkCrypt2 crypt;

	bool success;
	success = crypt.UnlockComponent("T12302015Crypt_sHyDCAFglR1v ");
	if (success != true) {
		printf("%s\n", crypt.lastErrorText());
		return;
	}

	//  AES is also known as Rijndael.
	crypt.put_CryptAlgorithm("aes");

	//  CipherMode may be "ecb" or "cbc"
	crypt.put_CipherMode("cbc");

	//  KeyLength may be 128, 192, 256
	crypt.put_KeyLength(256);

	//  The padding scheme determines the contents of the bytes
	//  that are added to pad the result to a multiple of the
	//  encryption algorithm's block size.  AES has a block
	//  size of 16 bytes, so encrypted output is always
	//  a multiple of 16.
	crypt.put_PaddingScheme(0);

	//  EncodingMode specifies the encoding of the output for
	//  encryption, and the input for decryption.
	//  It may be "hex", "url", "base64", or "quoted-printable".
	crypt.put_EncodingMode("hex");

	//  An initialization vector is required if using CBC mode.
	//  ECB mode does not use an IV.
	//  The length of the IV is equal to the algorithm's block size.
	//  It is NOT equal to the length of the key.
	const char * ivHex;
	ivHex = "000102030405060708090A0B0C0D0E0F";
	crypt.SetEncodedIV(ivHex, "hex");

	//  The secret key must equal the size of the key.  For
	//  256-bit encryption, the binary secret key is 32 bytes.
	//  For 128-bit encryption, the binary secret key is 16 bytes.
	const char * keyHex;
	keyHex = "000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F";
	crypt.SetEncodedKey(keyHex, "hex");

	//  Encrypt a string...
	//  The input string is 44 ANSI characters (i.e. 44 bytes), so
	//  the output should be 48 bytes (a multiple of 16).
	//  Because the output is a hex string, it should
	//  be 96 characters long (2 chars per byte).
	const char * encStr;
	encStr = crypt.encryptStringENC("The quick brown fox jumps over the lazy dog.");
	printf("%s\n", encStr);

	//  Now decrypt:
	const char * decStr;
	decStr = crypt.decryptStringENC(encStr);
	printf("%s\n", decStr);
}



int _tmain(int argc, _TCHAR* argv[])
{
	CreateSessionKey();
	key_press();
	RSA();
	key_press();
	AES();
	key_press();
	MessageBox(NULL, "Goodbye, cruel world!", "Note", MB_OK);
	return 0;
}

